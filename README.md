# Node Manager
Программа для загрузки, изменения и сохранения Node-ов.

## Задание
Есть структура данных:
```
class Node {
    val value: String
    val nodes: List<Node>
}
```
Нужно организовать утилиту (console app) для создания и редактирования такой структуры и сохранение в файл(и восстановление из файла).

## Мое понимание
Формулировка показалась мне не однозначной. Структура Node, данная в задании, по факту - вершина ориентированного графа. Предполагать, что в этом графе нет циклов было бы слишком смело с моей стороны. Я решал это задание из рассчета, что уиклы допустимы. Но тогда, если Node.nodes - val, невозможно создать граф, содержащий цикл. Кроме того, если Node.value - val, то при изменении value одной вершины пришлось бы ее пересоздавать, а следом все вершины, из которых она допустима(что восстановить практически невозможно). Поэтому я сделал оба этих поля var.
```
class Node(var value: String, var nodes: MutableList<Node> = mutableListOf())
```
Благодаря этому допущению, мне не пришлось как-либо еще менять Node(например, добавлять туда поля).

## Что я сделал
Я реализовал функции loadFromFile и saveToFile для Node, а также класс NodeManager для взаимодействия с Node извне. loadFromFile и saveToFile можно использовать отдельно от NodeManager. При сохранении Node я также сохраняю все его поддерево в формате:

первая строка - n - количество вершин в поддереве;

cледующие n строк - value i-го Node на i-й строке;

последние n строк - номера детей i-го Node на i-й строке.

Вершины пронумерованы в порядке обхода в дереве dfs, соответственно 0-я - корень, и loadFromFile после загрузки возвращает именно ее. Кроме того, saveToFile не копирует и не меняет содержимое ни одного Node. 

NodeManager - класс, позволяющий пользователю извне выполнять операции с Node. Его единственное поле - ```val savedNodes: ArrayList<Node>``` - своеобразный буфер, хранящий в себе Node, с которыми работает пользователь. Благодаря NodeManager main "не знает" о существовании класса Node. 
## Доступные команды
* **add arg1** - добавляет в конец буфера Node с пустым nodes и value = arg1
* **load arg1** - загружает Node из файла arg1 и добавляет его в конец буфера
* **save arg1 arg2** - сохраняет arg1-й Node из буфера в файл с именем arg2
* **rm arg1** - удаляет arg1-й Node из буфера
* **show arg1** - выводит value arg1-го Node из буфера, а также value каждого из его детей(nodes)
* **size** - выводит размер буфера
* **list** - выводит value каждого Node из буфера
* **change arg1 arg2** - заменяет value arg1-го Node из буфера на arg2
* **take_child arg1 arg2** - добавляет в конец буфера arg2-го ребенка arg1-го элемента буфера
* **add_child arg1 arg2** - добавляет arg2-й элемент буфера в nodes arg1-го элемента
* **rm_child arg1 arg2** - удаляет arg2-го ребенка из nodes arg1-го элемента буфера
* **exit** - завершает программу
## Сборка
При попытке собрать проект с помощью gradle у меня вылетала непонятная ошибка, поэтому я пользовался Build System "IntelliJ" (3-я опция при создании проекта)
